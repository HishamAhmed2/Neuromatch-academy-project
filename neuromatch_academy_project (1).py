# -*- coding: utf-8 -*-
"""Neuromatch academy Project

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OJ3YBeyF6J2FFJYfebllNQsVZuXVVBHz

## Loading of Steinmetz data

includes some visualizations
"""

#@title Data retrieval
import os, requests

fname = []
for j in range(3):
  fname.append('steinmetz_part%d.npz'%j)
url = ["https://osf.io/agvxh/download"]
url.append("https://osf.io/uv3mw/download")
url.append("https://osf.io/ehmw2/download")

for j in range(len(url)):
  if not os.path.isfile(fname[j]):
    try:
      r = requests.get(url[j])
    except requests.ConnectionError:
      print("!!! Failed to download data !!!")
    else:
      if r.status_code != requests.codes.ok:
        print("!!! Failed to download data !!!")
      else:
        with open(fname[j], "wb") as fid:
          fid.write(r.content)

#@title Import matplotlib and set defaults
from matplotlib import rcParams 
from matplotlib import pyplot as plt
rcParams['figure.figsize'] = [20, 4]
rcParams['font.size'] =15
rcParams['axes.spines.top'] = False
rcParams['axes.spines.right'] = False
rcParams['figure.autolayout'] = True

#@title Data loading
import numpy as np

alldat = np.array([])
for j in range(len(fname)):
  alldat = np.hstack((alldat, np.load('steinmetz_part%d.npz'%j, allow_pickle=True)['dat']))

# select just one of the recordings here. 11 is nice because it has some neurons in vis ctx. 
dat = alldat[11]
print(dat.keys())

#"Define our paramaters"
response_time =dat['response_time']
contrast_left=dat['contrast_left']
contrast_right= dat['contrast_right']
go_cue = dat['gocue']
feedback_type = dat['feedback_type']

response_time= response_time.flatten()
go_cue = go_cue.flatten()

response_time_after_gocue = response_time - go_cue 
contrast_difference = contrast_left - contrast_right


contrast_difference_0 = [ trial for trial in range(len(contrast_difference)) if contrast_difference[trial] == 0 ]
small_response_time = np.array([trail for trail in range(len(response_time_after_gocue[contrast_difference_0])) if response_time_after_gocue[trail] < 0.7 ])
large_response_time = np.array([trail for trail in range(len(response_time_after_gocue[contrast_difference_0])) if response_time_after_gocue[trail] > 0.7 ])


feedback_before_small = feedback_type[ small_response_time -1  ]
feedback_before_large = feedback_type[ large_response_time -1  ]

#"set logistic regression input"
reward = []
for i in feedback_type:
  if i == -1:
    i = 0
    reward.append(i)
  else:
    reward.append(i)

punishment = []
for i in feedback_type:
  if i == 1:
    i = 0
    punishment.append(i)
  else:
    i = 1
    punishment.append(i)

response_time_state=[]


for i in response_time_after_gocue:
  if i <= 0.7:
    i = 4
    response_time_state.append(i)
  else:
    i = 3
    response_time_state.append(i)

response_time_state = np.array(response_time_state)
reward = np.array(reward)
punishment = np.array(punishment)

reward = reward[contrast_difference_0]
punishment = punishment[contrast_difference_0]
response_time_state = response_time_state[contrast_difference_0]

contrast_difference_0 = np.array(contrast_difference_0)
contrast_difference_before_cd0 = contrast_difference[contrast_difference_0 - 1 ]

#"build logistic regression model"
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn import metrics
import seaborn as sn
import matplotlib.pyplot as plt

mice= {'reward':reward, 'no reward': punishment,'response_time_state':response_time_state}
df = pd.DataFrame( mice , columns= ['reward', 'no reward','response_time_state'])
X = df[['reward','no reward']]
y= df['response_time_state']
X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.25,random_state=0)
logistic_regression= LogisticRegression()
logistic_regression.fit(X_train,y_train)
y_pred=logistic_regression.predict(X_test)
confusion_matrix = pd.crosstab(y_test, y_pred, rownames=['Actual'], colnames=['Predicted'])
sn.heatmap(confusion_matrix, annot=True)
print('Accuracy: ',metrics.accuracy_score(y_test, y_pred))